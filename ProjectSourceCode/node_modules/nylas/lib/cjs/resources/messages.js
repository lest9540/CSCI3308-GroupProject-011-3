"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Messages = void 0;
const utils_js_1 = require("../utils.js");
const resource_js_1 = require("./resource.js");
const smartCompose_js_1 = require("./smartCompose.js");
/**
 * Nylas Messages API
 *
 * The Nylas Messages API allows you to list, find, update, delete, schedule, and send messages on user accounts.
 */
class Messages extends resource_js_1.Resource {
    constructor(apiClient) {
        super(apiClient);
        this.smartCompose = new smartCompose_js_1.SmartCompose(apiClient);
    }
    /**
     * Return all Messages
     * @return A list of messages
     */
    list({ identifier, queryParams, overrides, }) {
        const modifiedQueryParams = queryParams
            ? { ...queryParams }
            : undefined;
        // Transform some query params that are arrays into comma-delimited strings
        if (modifiedQueryParams && queryParams) {
            if (Array.isArray(queryParams?.anyEmail)) {
                delete modifiedQueryParams.anyEmail;
                modifiedQueryParams['any_email'] = queryParams.anyEmail.join(',');
            }
        }
        return super._list({
            queryParams: modifiedQueryParams,
            overrides,
            path: `/v3/grants/${identifier}/messages`,
        });
    }
    /**
     * Return a Message
     * @return The message
     */
    find({ identifier, messageId, overrides, queryParams, }) {
        return super._find({
            path: `/v3/grants/${identifier}/messages/${messageId}`,
            overrides,
            queryParams,
        });
    }
    /**
     * Update a Message
     * @return The updated message
     */
    update({ identifier, messageId, requestBody, overrides, }) {
        return super._update({
            path: `/v3/grants/${identifier}/messages/${messageId}`,
            requestBody,
            overrides,
        });
    }
    /**
     * Delete a Message
     * @return The deleted message
     */
    destroy({ identifier, messageId, overrides, }) {
        return super._destroy({
            path: `/v3/grants/${identifier}/messages/${messageId}`,
            overrides,
        });
    }
    /**
     * Send an email
     * @return The sent message
     */
    async send({ identifier, requestBody, overrides, }) {
        const path = `/v3/grants/${identifier}/messages/send`;
        const requestOptions = {
            method: 'POST',
            path,
            overrides,
        };
        // Use form data only if the attachment size is greater than 3mb
        const attachmentSize = requestBody.attachments?.reduce((total, attachment) => {
            return total + (attachment.size || 0);
        }, 0) || 0;
        if (attachmentSize >= Messages.MAXIMUM_JSON_ATTACHMENT_SIZE) {
            requestOptions.form = Messages._buildFormRequest(requestBody);
        }
        else {
            if (requestBody.attachments) {
                const processedAttachments = await (0, utils_js_1.encodeAttachmentStreams)(requestBody.attachments);
                requestOptions.body = {
                    ...requestBody,
                    attachments: processedAttachments,
                };
            }
            else {
                requestOptions.body = requestBody;
            }
        }
        return this.apiClient.request(requestOptions);
    }
    /**
     * Retrieve your scheduled messages
     * @return A list of scheduled messages
     */
    listScheduledMessages({ identifier, overrides, }) {
        return super._find({
            path: `/v3/grants/${identifier}/messages/schedules`,
            overrides,
        });
    }
    /**
     * Retrieve a scheduled message
     * @return The scheduled message
     */
    findScheduledMessage({ identifier, scheduleId, overrides, }) {
        return super._find({
            path: `/v3/grants/${identifier}/messages/schedules/${scheduleId}`,
            overrides,
        });
    }
    /**
     * Stop a scheduled message
     * @return The confirmation of the stopped scheduled message
     */
    stopScheduledMessage({ identifier, scheduleId, overrides, }) {
        return super._destroy({
            path: `/v3/grants/${identifier}/messages/schedules/${scheduleId}`,
            overrides,
        });
    }
    /**
     * Remove extra information from a list of messages
     * @return The list of cleaned messages
     */
    cleanMessages({ identifier, requestBody, overrides, }) {
        return this.apiClient.request({
            method: 'PUT',
            path: `/v3/grants/${identifier}/messages/clean`,
            body: requestBody,
            overrides,
        });
    }
    static _buildFormRequest(requestBody) {
        // FormData imports are funky, cjs needs to use .default, es6 doesn't
        const FD = require('form-data');
        const FormDataConstructor = FD.default || FD;
        const form = new FormDataConstructor();
        // Split out the message payload from the attachments
        const messagePayload = {
            ...requestBody,
            attachments: undefined,
        };
        form.append('message', JSON.stringify((0, utils_js_1.objKeysToSnakeCase)(messagePayload)));
        // Add a separate form field for each attachment
        requestBody.attachments?.forEach((attachment, index) => {
            const contentId = attachment.contentId || `file${index}`;
            form.append(contentId, attachment.content, {
                filename: attachment.filename,
                contentType: attachment.contentType,
            });
        });
        return form;
    }
}
exports.Messages = Messages;
// The maximum size of an attachment that can be sent using json
Messages.MAXIMUM_JSON_ATTACHMENT_SIZE = 3 * 1024 * 1024;
